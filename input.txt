********Create array wof mapsWithDuplicate:***********
1.func readLines(path string) []string {
  	file, err := os.Open(path)
  	if err != nil {
  		return nil
  	}
  	defer file.Close()

  	scanner := bufio.NewScanner(file)
  	var lines []string
  	for scanner.Scan() {
  		lines = append(lines, scanner.Text())
  	}

  	return lines
  }

2. func createMyMap(lines []string, myarray *[]mapsWithDuplicate) *[]mapsWithDuplicate {
     	*myarray = append(*myarray,mapsWithDuplicate{"S0","S"})//create a separate function for this later
     	for i:=0;i<len(lines);i++  {
     		for j:=0;j<len(lines[i]) ;j++  {
     			if lines[i][j] == '-' {
     				*myarray = append(*myarray,mapsWithDuplicate{lines[i][:j], lines[i][j+1:]})
     			}
     		}
     	}
     	return myarray
     }

************REMOVE EPSILON PRODUCTIONS***************

1.  func removeEpsilonProduction(myArray *[]mapsWithDuplicate) *[]mapsWithDuplicate {
    	var arrayToRemove []mapsWithDuplicate
    	for i:=0;i<len(*myArray) ;i++  {
    		if (*myArray)[i].values == "ε" {
    			arrayToRemove = append(arrayToRemove,(*myArray)[i])
    			makeSubstitution(myArray,findEpsilonProductionsSymbols(myArray))
    			deleteMultipleElements1(myArray,arrayToRemove)
    		}
    	}
    	return myArray
    }



2.  func makeSubstitution(myArray *[]mapsWithDuplicate,stringsArray []string) *[]mapsWithDuplicate{
   	for i:=0;i<len(*myArray);i++  {
   		for j:=0;j<len(stringsArray) ;j++  {
   			/*fmt.Printf("%s--->%s==%t\n",myArray[i].values,stringsArray[j],contains(myArray[i].values,stringsArray[j]))*/
   			if contains((*myArray)[i].values,stringsArray[j]) {
   				*myArray = append(*myArray,mapsWithDuplicate{(*myArray)[i].symbols,myTrimFunc((*myArray)[i].values,stringsArray[j])})
   			}
   		}
   	}
   	return myArray
   }


3.  func findEpsilonProductionsSymbols(myArray *[]mapsWithDuplicate) []string{
   	var epsilonArray []string
   	for i:=0;i<len(*myArray) ;i++  {
   		if (*myArray)[i].values == "ε" {
   			epsilonArray = append(epsilonArray,(*myArray)[i].symbols)
   		}
   	}
   	return epsilonArray

   }
**********************UTILS**************
1. func deleteMultipleElements1(baseArray *[]mapsWithDuplicate, arrayToDelete []mapsWithDuplicate) *[]mapsWithDuplicate {
      	for i:=0;i<len(*baseArray);i++{
      		url := (*baseArray)[i]
      		for _,rem := range arrayToDelete{
      			if url==rem {
      				*baseArray = append((*baseArray)[:i],(*baseArray)[i+1:]...)
      				i--
      				break
      			}
      		}
      	}
      	return baseArray

      }

2.  func myTrimFunc(word string,charToTrim string) string{

   	myRunes := []rune(word)
   	for i:=0;i<len(myRunes) ;i++  {
   		if string(myRunes[i]) == charToTrim && len(string(myRunes))>1{
   			myRunes := append(myRunes[:i],myRunes[i+1:]...)
   			return string(myRunes)
   		} else if word == charToTrim{//be carefull here also can be len(word)==1
   			myRunes[i] = 949
   			return string(myRunes)
   		}
   	}
   	return "WORD DOES NOT CONTAIN CHARACTER"
   }

3.  func contains (word string,char string) bool{
   	for i:=0;i<len(word) ;i++  {
   		if string(word[i]) == char {
   			return true
   		}
   	}
   	return false
   }